#!/bin/bash

nFiles=5

trap "echo -e 'Not all Logs in ../04/.\nExit Error'; exit 1" TERM
ftCheckExistingFiles()
{
	local ret=""
	for (( i=1; i<=$nFiles; i++ ))
	do
		if [[ ! -f "../04/log$i.txt" ]]
		then kill -s TERM $$
		fi
		ret=$ret" ../04/log$i.txt"
	done
	echo $ret
}

#ftMove()
#{
#	regExpr='^[log]+[1-5][.txt]+$'
#	if [[ "log2.txt" =~ $regExpr ]]
#	then echo YES; exit 0
#	else echo NO; exit 1
#	fi
#}

ftSortByCode()
{
	#local FilesForAwk=$(ftCheckExistingFiles)
	awk 'NR' ${FilesForAwk} | sort -t $' ' -k6
	#-t $'\t' задаст разделитель полей как tab.
	#По умолчанию пробел. --> можно не указывать -t $' '
	#-k6,6 для сортировки из столбца 6 в столбец 6. Также при -k6.
	#-k1n будет означать числовую сортировку 1го столбца
	#по умолчанию порядок возрастания. -k6r -k6,6r -k1nr для убывания
}

ftUniqIP()
{
	awk '
	{
	    if (!($1 in a)) 
	        a[$1] = $1;
       	}
	END { 
	    for (i in a) 
	       print a[i]
	}' $FilesForAwk

	# 'a' это массив., индексируется строкой $1 (=IP)
	#Идём по всем строкам, смотрим первый столбец $1 он же ip.
	#Если в 'а' не существует элемента, индексируемого строкой $1 (IP),
	#то в элемент a[$1], т.е. в элемент, индексируемый строкой
	#равной текущему рассматриваемому ip (столбцу $1), мы
	#записываем этот ip; a[$1] = $1.
	#После обработки всех строк, элементы массива - уникальные ip;
	#Распечатаем их:  END {for (i in a) print a[i]}' 

	#Sort и uniq выводят уникальные IP, но отсортированные!
	#awk '{print $1}' ${FilesForAwk}| sort -u
        #awk '{print $1}' ${FilesForAwk}|sort| uniq -c
	#-c для каждого уникального IP покажет количество дубликатов
}

ftErrorRequests()
{
	echo "Three"
}

ftUniqIPinErrorRequests()
{
	echo "Four"
}
